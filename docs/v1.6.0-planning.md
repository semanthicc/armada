# v1.6.0 Planning: AST Chunking Decision

## Test Results Recap

From [lsp-vs-semantic-comparison.md](./lsp-vs-semantic-comparison.md):

| Query Type | Semantic Result | LSP Result | Semantic Quality |
|-----------|----------------|--------------|-----------------|
| **Synonyms** ("login") | âœ… Found relevant code | âŒ None | Good |
| **Exact symbol** ("saveEmbeddingConfig") | âš ï¸ Noisy (tests/docs) | âœ… Exact location | Poor for exact |
| **Technical** ("function that saves embedding config") | âœ… Found `updateProjectEmbeddingConfig` | N/A | **Excellent** |
| **Cross-ref** ("where is X used") | âš ï¸ Misses some | âœ… Complete | Good enough |

**Key Finding**: Semantic search **excels at technical/coding queries** but struggles with exact symbol lookups.

---

## Would AST Chunking Help?

### What AST Solves

| Problem | Current (Token-based) | AST Solution | Impact |
|---------|----------------------|---------------|---------|
| Split mid-function | May return half function | Function = atomic chunk | ğŸŸ¡ Moderate |
| Result attribution | "lines 45-89" | "function processPayment" | ğŸŸ¢ UX benefit |
| Context continuity | 3-line overlap | No overlap needed | ğŸŸ¢ Storage + |
| Docstring attachment | May be separate | Attached to function | ğŸŸ¡ Quality + |

### What AST Doesn't Fix

| Problem | AST Chunking | Why |
|---------|---------------|------|
| **Exact symbol search** | No help | LSP already handles this |
| **Test/doc noise** | No help | Prioritization issue, not chunking |
| **Stale index** | No help | Needs reindex |
| **Dimension mismatch** | No help | Fixed in v1.4.1 |
| **Anonymous functions** | Limited help | No name to attach |

---

## Analysis Based on Test Results

### 1. Semantic Search Quality

**Finding**: Semantic search **works well** for technical queries:

```
Query: "function that saves embedding config"
Result: updateProjectEmbeddingConfig in config.ts
```

**Question**: Did we miss anything due to split chunks?

**Answer**: We found the target. Chunking didn't matter here because the embedding matched.

### 2. Retrieval Completeness

**Hypothesis**: If a 500-line function is split, searching for "middle logic" might miss it.

**Test needed**: Query specific logic from middle of large function.

**Reality check**: How many functions in codebase are >500 lines?
- Most functions: 20-100 lines
- AST chunking benefit: Limited to <5% of code

### 3. User Experience vs Complexity

| Metric | Token Chunking | AST Chunking |
|---------|---------------|---------------|
| **Implementation** | âœ… Done (0 days) | âŒ ~13h work |
| **Dependencies** | None | tree-sitter (~3MB), grammars |
| **Language support** | âœ… Universal | âŒ TS/JS only initially |
| **Maintenance** | âœ… Minimal | âŒ Grammar updates |
| **Result clarity** | "lines 45-89" | "function processPayment" |
| **Performance** | Fast | Parsing overhead (~100-500ms) |

---

## Verdict: DEFER AST CHUNKING

### Reasons:

1. **Marginal benefit for current codebases**
   - 95% of functions <300 lines
   - Semantic search already finds code effectively
   - Test results show good recall

2. **Wrong problem to solve**
   - Real issue: test/doc noise outranking code
   - Not issue: split chunks missing code
   - Solution: Boost code over docs, not AST chunking

3. **High complexity for v1.6.0**
   - 13h implementation time
   - Language support gaps
   - Adds 3MB to package size

4. **LSP covers structured use cases**
   - Symbol lookup â†’ LSP
   - Find references â†’ LSP
   - Navigate hierarchy â†’ LSP
   - Semantic is for **conceptual** search

---

## What Should We Do Instead? (Better ROI)

### Priority 1: Boost Code Results ğŸ”¥

**Problem**: "function that..." queries return tests/docs first.

**Solution**: Add content type boosting in hybrid search.

```typescript
// Pseudo-code
searchResults = hybridSearch(query);
scored = searchResults.map(r => ({
  ...r,
  score: r.similarity + (r.chunkType === 'code' ? 0.2 : 0)
}));
```

**Effort**: 2h
**Impact**: Huge - users see actual code first.

### Priority 2: Improve Chunk Metadata ğŸ”¥

**Current**: Only filename + line range.

**Proposed**: Add symbol context to chunks.

```typescript
interface EmbeddingRecord {
  ...current,
  symbolName?: string,    // Extract from regex
  symbolType?: string,    // "function" | "class" | "interface"
  docstring?: string,      // Attached JSDoc
}
```

**Effort**: 4h
**Impact**: Better result attribution without full AST.

### Priority 3: Query Understanding ğŸŸ¡

**Problem**: Natural language queries inconsistent.

**Solution**: Expand query with synonyms, common coding patterns.

```typescript
expandQuery("login user") â†’ ["login user", "authenticate", "sign in", "verify token"]
```

**Effort**: 3h
**Impact**: Better recall for varied user queries.

---

## Deferred to Future (When These Emerge)

Implement AST chunking when:

- [ ] User feedback: "I'm getting half-functions in results"
- [ ] Performance tests show: token chunking causes missed results
- [ ] Multi-language monorepo support is priority
- [ ] >50% of target codebase has >300-line functions

---

## Conclusion

**Don't do AST chunking for v1.6.0.**

Instead:
1. âœ… Boost code over tests/docs (2h) - **BIGGEST IMPACT**
2. âœ… Add symbol-level metadata (4h) - **NO AST NEEDED**
3. âœ… Query expansion (3h) - **IMPROVES RECALL**
4. âŒ AST chunking (~13h) - **LOW ROI**

**Total time**: 9h for 3 high-impact improvements vs 13h for marginal AST benefit.

---

## Recommended v1.6.0 Scope

| Feature | Effort | Impact | Priority |
|---------|----------|--------|----------|
| **Abort Indexing** | 3h | ğŸŸ¢ UX | 1 |
| Code result boosting | 2h | ğŸ”¥ HUGE | 2 |
| Symbol metadata extraction | 4h | ğŸ”¥ HIGH | 3 |
| Query expansion | 3h | ğŸŸ¡ MEDIUM | 4 |
| Performance monitoring | 3h | ğŸŸ¢ LOW | 5 |
| AST chunking | 13h | ğŸŸ¢ LOW | 6 (DEFERRED) |

**Total for v1.6.0 MVP**: ~12h
**Total with AST chunking**: 22h
**Benefit**: 90% of improvement, 40% of the work.
